{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Documentation","text":""},{"location":"development/index.html","title":"Development","text":"<p>This documentation is to help you contribute to the project.</p> <p>For backend development, checkout this documentation.</p>"},{"location":"development/backend/index.html","title":"Backend Development","text":""},{"location":"development/backend/index.html#environment-setup","title":"Environment Setup","text":""},{"location":"development/backend/index.html#prerequisites","title":"Prerequisites","text":"<ol> <li>Install Devenv on your system.</li> <li>Ensure you have a compatible package manager (e.g., <code>nix</code>).</li> </ol>"},{"location":"development/backend/index.html#getting-started","title":"Getting Started","text":"<ol> <li> <p>Clone the repository:</p> <p><code>bash git clone https://github.com/4t-24/4ctf &amp;&amp; cd 4ctf</code></p> </li> <li> <p>Start the development environment:</p> <p><code>bash devenv up</code></p> </li> <li> <p>Open a development shell:</p> <p><code>bash devenv shell</code></p> </li> </ol>"},{"location":"development/backend/index.html#features-and-usage","title":"Features and Usage","text":""},{"location":"development/backend/index.html#environment-variables","title":"Environment Variables","text":""},{"location":"development/backend/index.html#installed-packages","title":"Installed Packages","text":"<ul> <li><code>git</code> for version control.</li> <li><code>go</code> for backend development.</li> <li><code>golangci-lint</code> for linting Go code.</li> </ul>"},{"location":"development/backend/index.html#installed-tools","title":"Installed Tools","text":"<ul> <li><code>air</code>: A live-reloading tool for Go development, installed automatically during setup.</li> </ul>"},{"location":"development/backend/index.html#development-shell","title":"Development Shell","text":"<p>You can enter the development shell by using  : <code>devenv shell</code>. This allows you to have all the necessary tools to develop properly.</p>"},{"location":"development/backend/database.html","title":"Database","text":"<p>This project uses dbmate and sqlboiler for managing database migrations and ORM-based data handling, respectively. The environment variables for database configuration are automatically loaded with devenv, simplifying database operations like migrations and generating Go models.</p>"},{"location":"development/backend/database.html#requirements","title":"Requirements","text":"<ul> <li>devenv</li> <li>docker</li> </ul>"},{"location":"development/backend/database.html#setup","title":"Setup","text":"<p>Before using dbmate or sqlboiler, ensure that you have the appropriate environment variables set. These are automatically loaded through devenv, so you can simply navigate to the <code>back</code> directory to begin working with the database.</p>"},{"location":"development/backend/database.html#environment-variables","title":"Environment Variables","text":"<p>Environment variables are automatically managed using devenv. This makes it easy to load the necessary configuration and start working with the database without having to manually set up variables each time.</p>"},{"location":"development/backend/database.html#migrations-with-dbmate","title":"Migrations with dbmate","text":"<p>dbmate is used for managing database migrations. It simplifies the process of creating, applying, and rolling back database migrations.</p>"},{"location":"development/backend/database.html#commands","title":"Commands","text":"<ul> <li>Create a new migration:   To create a new migration file, run the following command from the <code>back</code> directory:</li> </ul> <p><code>bash   dbmate new &lt;migration_name&gt;</code></p> <ul> <li>Apply migrations:   To apply any pending migrations to the database, use:</li> </ul> <p><code>bash   dbmate up</code></p> <ul> <li>Rollback migrations:   To rollback the most recent migration, use:</li> </ul> <p><code>bash   dbmate down</code></p> <ul> <li>Reset the database:   To reset the database, i.e., drop all tables and reapply all migrations, run:</li> </ul> <p><code>bash   dbmate reset</code></p>"},{"location":"development/backend/database.html#documentation-for-dbmate","title":"Documentation for dbmate","text":"<p>For more detailed information about how to use dbmate for database migrations, refer to the official documentation:</p> <ul> <li>dbmate GitHub Repository</li> </ul>"},{"location":"development/backend/database.html#orm-with-sqlboiler","title":"ORM with sqlboiler","text":"<p>sqlboiler is used to generate Go models from the database schema. It simplifies working with the database by providing strongly typed Go structs for database tables.</p>"},{"location":"development/backend/database.html#generate-models","title":"Generate Models","text":"<p>After updating the database schema (e.g., by running migrations), you can regenerate the Go models by running:</p> <pre><code>go generate .\n</code></pre> <p>This will automatically generate or update the models based on the current state of the database.</p>"},{"location":"development/backend/database.html#documentation-for-sqlboiler","title":"Documentation for sqlboiler","text":"<p>For more information on how to use sqlboiler to work with Go models and interact with the database, refer to the official documentation:</p> <ul> <li>sqlboiler GitHub Repository</li> <li>sqlboiler Documentation</li> </ul>"},{"location":"development/backend/database.html#best-practices","title":"Best Practices","text":"<ul> <li>Version Control: Keep migration files in version control to ensure consistency across environments.</li> <li>Generate Models: After each migration, run <code>go generate .</code> to regenerate the Go models so they stay in sync with the database schema.</li> <li>Environment Consistency: Use devenv to ensure that the environment variables are always loaded correctly before interacting with the database.</li> </ul>"},{"location":"development/backend/middlewares.html","title":"Middleware Documentation","text":"<p>The following middlewares are used to handle common tasks such as session management, request validation, and ensuring the integrity of incoming data. These middlewares are used in the API routes to ensure that the incoming requests meet certain conditions before passing them to the corresponding handlers.</p>"},{"location":"development/backend/middlewares.html#overview","title":"Overview","text":"<ul> <li>WithDefaults: Ensures that session information is loaded, and the logger is initialized for each request.</li> <li>WithBody: Validates the body of the request according to the defined validation rules.</li> <li>WithValidSession: Ensures that the session is valid before processing the request.</li> </ul>"},{"location":"development/backend/middlewares.html#middleware-functions","title":"Middleware Functions","text":"<p>Each middleware function takes an API instance (<code>*Api</code>) and returns a handler function that performs some processing before calling the original handler.</p>"},{"location":"development/backend/middlewares.html#withdefaults","title":"<code>WithDefaults</code>","text":"<p>The <code>WithDefaults</code> middleware sets up the session and logger for each request. It ensures that the session information is properly loaded and updated during the request handling.</p>"},{"location":"development/backend/middlewares.html#function-signature","title":"Function Signature","text":"<pre><code>func WithDefaults(api *Api, fn func(api *Api) func(ctx *atreugo.RequestCtx) error) func(ctx *atreugo.RequestCtx) error\n</code></pre>"},{"location":"development/backend/middlewares.html#how-it-works","title":"How It Works","text":"<ol> <li>The middleware retrieves the session information using <code>api.session.GetSession</code>.</li> <li>It sets the session into the request context so that it can be accessed by downstream handlers.</li> <li>The <code>api</code> object is reinitialized with the session and logger for the specific request.</li> <li>The original handler is executed, and after the handler runs, it checks if the session has been updated. If so, the session is saved back.</li> </ol>"},{"location":"development/backend/middlewares.html#example-usage","title":"Example Usage","text":"<pre><code>group.POST(\"/some-endpoint\", WithDefaults(api, someHandler))\n</code></pre> <p>This will ensure that the session is available in the request context and that logging is correctly handled.</p>"},{"location":"development/backend/middlewares.html#withbody","title":"<code>WithBody</code>","text":"<p>The <code>WithBody</code> middleware is used to parse and validate the request body. It unmarshals the incoming JSON data into a Go struct and validates it according to the rules defined in the struct tags. If validation fails, a <code>400 Bad Request</code> response is returned.</p>"},{"location":"development/backend/middlewares.html#function-signature_1","title":"Function Signature","text":"<pre><code>func WithBody[K any](fn func(api *Api) func(ctx *atreugo.RequestCtx, body K) error) func(api *Api) func(ctx *atreugo.RequestCtx) error\n</code></pre>"},{"location":"development/backend/middlewares.html#how-it-works_1","title":"How It Works","text":"<ol> <li>The middleware unmarshals the incoming JSON request body into a struct of type <code>K</code>.</li> <li>It validates the struct using the <code>validator.Validate</code> function.</li> <li>If the body is invalid, a <code>400 Bad Request</code> response is returned with details of the validation errors.</li> <li>If the body is valid, the original handler is called with the validated data.</li> </ol>"},{"location":"development/backend/middlewares.html#example-usage_1","title":"Example Usage","text":"<pre><code>func register(api *Api) func(ctx *atreugo.RequestCtx, rr *RegisterRequest) error {\n    return func(ctx *atreugo.RequestCtx, rr *RegisterRequest) error {\n        // Handler logic\n    }\n}\n\ngroup.POST(\"/register\", WithDefaults(api, WithBody(register)))\n</code></pre> <p>In this example, the body of the request is validated using the rules defined in the <code>RegisterRequest</code> struct before the <code>register</code> handler is invoked.</p>"},{"location":"development/backend/middlewares.html#withvalidsession","title":"<code>WithValidSession</code>","text":"<p>The <code>WithValidSession</code> middleware ensures that the current user session is valid before proceeding with the request. If the session is not valid, it returns a <code>401 Unauthorized</code> response.</p>"},{"location":"development/backend/middlewares.html#function-signature_2","title":"Function Signature","text":"<pre><code>func WithValidSession(fn func(api *Api) func(ctx *atreugo.RequestCtx) error) func(api *Api) func(ctx *atreugo.RequestCtx) error\n</code></pre>"},{"location":"development/backend/middlewares.html#how-it-works_2","title":"How It Works","text":"<ol> <li>The middleware checks if the session associated with the request is valid.</li> <li>If the session is not valid, it returns a <code>401 Unauthorized</code> response.</li> <li>If the session is valid, the original handler is called.</li> </ol>"},{"location":"development/backend/middlewares.html#example-usage_2","title":"Example Usage","text":"<pre><code>group.GET(\"/protected-endpoint\", WithDefaults(api, WithValidSession(protectedHandler)))\n</code></pre> <p>In this example, the <code>protectedHandler</code> will only be executed if the session is valid.</p>"},{"location":"development/backend/middlewares.html#error-handling","title":"Error Handling","text":"<p>For each middleware, if an error occurs (e.g., invalid request body, invalid session), an appropriate error response is returned:</p> <ul> <li><code>400 Bad Request</code> for invalid request bodies or validation errors.</li> <li><code>401 Unauthorized</code> for invalid or expired sessions.</li> </ul> <p>Each middleware logs the error details, including the IP address of the requester, to assist in debugging and monitoring.</p>"},{"location":"development/backend/middlewares.html#best-practices","title":"Best Practices","text":"<ul> <li>Session Management: Use <code>WithDefaults</code> and <code>WithValidSession</code> to ensure that session data is consistently available and valid.</li> <li>Request Validation: Use <code>WithBody</code> for automatic validation of incoming request bodies to prevent invalid data from reaching the handler.</li> <li>Error Handling: Ensure that each middleware returns appropriate error responses and logs relevant information for debugging.</li> </ul>"},{"location":"development/backend/validators.html","title":"Validator Documentation","text":"<p>The <code>validators</code> package is used to ensure that incoming request data is valid according to predefined rules. The package integrates with the API to perform validation checks before the request is processed further.</p>"},{"location":"development/backend/validators.html#overview","title":"Overview","text":"<p>Each incoming request body is validated using a set of validation rules defined in the struct tags. The validation is performed automatically by the <code>WithBody</code> middleware before passing control to the corresponding handler.</p>"},{"location":"development/backend/validators.html#example-register-request","title":"Example: Register Request","text":"<p>Here\u2019s an example of a <code>RegisterRequest</code> struct with validation rules:</p> <pre><code>type RegisterRequest struct {\n    Email    string `json:\"email\" validate:\"nonzero,email\"`\n    Username string `json:\"username\" validate:\"min=2,max=40,regexp=^[a-zA-Z]*$\"`\n    Password string `json:\"password\" validate:\"max=256,password\"`\n}\n</code></pre> <p>In this example:</p> <ul> <li><code>Email</code> must be non-empty and a valid email format.</li> <li><code>Username</code> must be between 2 and 40 characters long and only contain alphabetic characters.</li> <li><code>Password</code> must not exceed 256 characters and must meet certain password criteria (such as length, type).</li> </ul> <p>The validation rules are specified using tags in the struct definition, following the syntax supported by the validator library.</p>"},{"location":"development/backend/validators.html#how-it-works","title":"How It Works","text":"<p>The validation process is integrated into the request handling using a middleware function. The middleware automatically checks the request body against the validation rules defined in the model struct.</p>"},{"location":"development/backend/validators.html#withbody-middleware","title":"<code>WithBody</code> Middleware","text":"<p>The <code>WithBody</code> middleware is responsible for:</p> <ol> <li>Parsing the body: It unmarshals the incoming JSON request body into the specified struct (<code>K</code>).</li> <li>Validating the body: It validates the parsed struct using the <code>validator.Validate</code> function. If the body does not meet the validation rules, the middleware returns a <code>400 Bad Request</code> response with the corresponding error messages.</li> <li>Calling the handler: If the body passes validation, the middleware calls the original handler with the validated data.</li> </ol> <p>Here is the middleware function:</p> <pre><code>func WithBody[K any](fn func(api *Api) func(ctx *atreugo.RequestCtx, body K) error) func(api *Api) func(ctx *atreugo.RequestCtx) error {\n    return func(api *Api) func(ctx *atreugo.RequestCtx) error {\n        return func(ctx *atreugo.RequestCtx) error {\n            var body K\n            if err := json.Unmarshal(ctx.PostBody(), &amp;body); err != nil {\n                logrus.\n                    WithField(\"request_ip\", ctx.RemoteIP().String()).\n                    WithError(err).\n                    Warn(\"bad request\")\n                return ctx.JSONResponse(NewErrorResponse(400, []ResponseError{{Message: \"Bad request\"}}))\n            }\n\n            if err := validator.Validate(body); err != nil {\n                logrus.\n                    WithField(\"request_ip\", ctx.RemoteIP().String()).\n                    WithError(err).\n                    Warn(\"invalid request\")\n                return ctx.JSONResponse(NewErrorResponse(400, validatorErrorToResponseError(err)))\n            }\n\n            return fn(api)(ctx, body)\n        }\n    }\n}\n</code></pre>"},{"location":"development/backend/validators.html#example-of-usage-in-a-route","title":"Example of Usage in a Route","text":"<p>You can use the <code>WithBody</code> middleware to validate the request body in your routes. For example, in the <code>register</code> route:</p> <pre><code>group.POST(\"/register\", WithDefaults(api, WithBody(register)))\n\nfunc register(api *Api) func(ctx *atreugo.RequestCtx, rr *RegisterRequest) error {\n    return func(ctx *atreugo.RequestCtx, rr *RegisterRequest) error {\n        // handler logic\n    }\n}\n</code></pre> <p>In this example, the <code>register</code> handler receives a <code>RegisterRequest</code> object that has already been validated.</p>"},{"location":"development/backend/validators.html#validator-rules","title":"Validator Rules","text":"<p>For default validators, check out the package's documentation</p> <ul> <li><code>email</code>: Ensures the field is a valid email address.</li> <li><code>password</code>: Custom password validation rule that include checks for complexity and length.</li> </ul>"},{"location":"development/backend/validators.html#error-handling","title":"Error Handling","text":"<p>If validation fails, the middleware will log the error and return a <code>400 Bad Request</code> response with detailed error messages. The <code>validatorErrorToResponseError</code> function formats the validation errors into a response-friendly format.</p> <p>Example error response:</p> <pre><code>{\n  \"status\": 400,\n  \"errors\": [\n    {\n      \"field\": \"Email\",\n      \"message\": \"Email must be a valid email address\"\n    }\n  ]\n}\n</code></pre>"},{"location":"development/backend/validators.html#best-practices","title":"Best Practices","text":"<ul> <li>Use specific validation rules: Apply the correct validation rule to each field (e.g., <code>email</code>, <code>min</code>, <code>max</code>, <code>regexp</code>).</li> <li>Limit validation complexity: Keep the validation rules simple and focused to avoid unnecessary overhead in request processing.</li> <li>Log validation errors: Ensure that all validation errors are logged to help with debugging and monitoring.</li> </ul>"},{"location":"development/backend/views.html","title":"Views Package","text":"<p>The <code>views</code> package provides a flexible and secure system for controlling the visibility of fields when serializing data in your API. This system ensures that different roles or contexts receive only the necessary data.</p>"},{"location":"development/backend/views.html#overview","title":"Overview","text":"<p>A view is a struct that defines which fields should be serialized and sent to the user, based on their visibility level. Each field in a view has a <code>visible</code> tag that specifies the roles or contexts in which the field should be included.</p> <p>For example, the <code>userView</code> struct controls the serialization of user data:</p> <pre><code>type userView struct {\n    ID                     *uint64      `json:\"id,omitempty\" visible:\"admin,user,other\"`\n    Username               *string      `json:\"username,omitempty\" visible:\"admin,user,other\"`\n    PasswordHash           *string      `json:\"password_hash,omitempty\" visible:\"nobody\"`\n    Email                  *string      `json:\"email,omitempty\" visible:\"admin,user\"`\n    EmailVerified          *bool        `json:\"email_verified,omitempty\" visible:\"admin,user\"`\n    EmailVerificationToken *null.String `json:\"email_verification_token,omitempty\" visible:\"admin\"`\n    IsAdmin                *bool        `json:\"is_admin,omitempty\" visible:\"admin\"`\n    IsHidden               *bool        `json:\"is_hidden,omitempty\" visible:\"admin\"`\n    CreatedAt              *time.Time   `json:\"-\" visible:\"admin\"`\n    UpdatedAt              *time.Time   `json:\"-\" visible:\"admin\"`\n    DeletedAt              *null.Time   `json:\"-\" visible:\"admin\"`\n}\n</code></pre>"},{"location":"development/backend/views.html#visibility-levels","title":"Visibility Levels","text":"<ul> <li><code>admin</code>: Visible to administrators.</li> <li><code>user</code>: Visible to the user themselves.</li> <li><code>other</code>: Visible to other roles (e.g., public viewers).</li> <li><code>nobody</code>: Not visible to anyone.</li> <li>Fields can also use <code>json:\"-\"</code> to ensure they are not serialized at all.</li> </ul>"},{"location":"development/backend/views.html#creating-a-view","title":"Creating a View","text":"<p>To create a new view, define a struct with the desired fields and <code>visible</code> tags. Implement a function to map the model data to the view struct. For example:</p> <pre><code>func UserView(user *models.User) *userView {\n    return &amp;userView{\n        ID:                     &amp;user.ID,\n        Username:               &amp;user.Username,\n        PasswordHash:           &amp;user.PasswordHash,\n        Email:                  &amp;user.Email,\n        EmailVerified:          &amp;user.EmailVerified,\n        EmailVerificationToken: &amp;user.EmailVerificationToken,\n        IsAdmin:                &amp;user.IsAdmin,\n        IsHidden:               &amp;user.IsHidden,\n        CreatedAt:              &amp;user.CreatedAt,\n        UpdatedAt:              &amp;user.UpdatedAt,\n        DeletedAt:              &amp;user.DeletedAt,\n    }\n}\n</code></pre>"},{"location":"development/backend/views.html#using-views-in-handlers","title":"Using Views in Handlers","text":"<p>To use a view in an API handler, call the appropriate view function and return it in the response. For example:</p> <pre><code>func profile(api *Api) func(ctx *atreugo.RequestCtx) error {\n    return func(ctx *atreugo.RequestCtx) error {\n        session := ctx.UserValue(\"session\").(*Session)\n\n        userSession, err := models.UserSessions(models.UserSessionWhere.ID.EQ(session.UserSessionID)).OneG(ctx)\n        if err != nil {\n            ...\n        }\n\n        user, err := userSession.User().OneG(ctx)\n        if err != nil {\n            ...\n        }\n\n        return ctx.JSONResponse(NewResponse(200, views.Return(user, user, views.UserView(user))))\n    }\n}\n</code></pre> <p>The params are explained by your IDE, the first one is the viewer, the second one the owner of the resource, and the third one is the model you want to send.</p>"},{"location":"development/backend/views.html#explanation-of-viewsreturn","title":"Explanation of <code>views.Return</code>","text":"<p>The <code>views.Return</code> function is responsible for applying the visibility rules to the view. It takes the current user (to determine their role) and the data to be serialized.</p>"},{"location":"development/backend/views.html#updating-views","title":"Updating Views","text":"<p>To update an existing view:</p> <ol> <li>Modify the struct to add, remove, or update fields.</li> <li>Update the <code>visible</code> tags to reflect the new visibility rules.</li> <li>Update the corresponding view function to map any new or removed fields.</li> </ol>"},{"location":"development/backend/views.html#adding-a-new-view","title":"Adding a New View","text":"<p>To add a new view:</p> <ol> <li>Define a new struct in the <code>views</code> package.</li> <li>Add appropriate <code>json</code> and <code>visible</code> tags to each field.</li> <li>Implement a function to map the model data to the view struct.</li> <li>Use the new view in your handlers as needed.</li> </ol>"},{"location":"development/backend/views.html#example-creating-a-productview","title":"Example: Creating a <code>productView</code>","text":"<pre><code>type productView struct {\n    ID          *uint64 `json:\"id,omitempty\" visible:\"admin,user,other\"`\n    Name        *string `json:\"name,omitempty\" visible:\"admin,user,other\"`\n    Description *string `json:\"description,omitempty\" visible:\"admin,user\"`\n    Price       *float64 `json:\"price,omitempty\" visible:\"admin,user\"`\n}\n\nfunc ProductView(product *models.Product) *productView {\n    return &amp;productView{\n        ID:          &amp;product.ID,\n        Name:        &amp;product.Name,\n        Description: &amp;product.Description,\n        Price:       &amp;product.Price,\n    }\n}\n</code></pre>"},{"location":"development/backend/views.html#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>visible</code> tags carefully: Avoid exposing sensitive information (e.g., passwords, tokens) to unintended roles.</li> <li>Keep view structs minimal: Only include fields that are necessary for the given context.</li> <li>Test visibility rules: Ensure fields are visible only to the intended roles.</li> </ul>"},{"location":"development/backend/views.html#future-improvements","title":"Future Improvements","text":"<ul> <li>Implement a utility function to automatically filter fields based on the <code>visible</code> tag, reducing boilerplate in handlers.</li> <li>Introduce logging or testing utilities to verify that no sensitive data is leaked inadvertently.</li> </ul>"}]}